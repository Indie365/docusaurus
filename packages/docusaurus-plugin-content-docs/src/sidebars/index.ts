/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import fs from 'fs-extra';
import importFresh from 'import-fresh';
import type {
  SidebarsConfig,
  Sidebars,
  NormalizedSidebars,
  CategoryMetadataFile,
} from './types';
import type {NormalizeSidebarsParams} from '../types';
import {validateSidebars, validateCategoryMetadataFile} from './validation';
import {normalizeSidebars} from './normalization';
import {processSidebars, type SidebarProcessorParams} from './processor';
import path from 'path';
import {createSlugger, Globby} from '@docusaurus/utils';
import logger from '@docusaurus/logger';
import type {PluginOptions} from '@docusaurus/plugin-content-docs';
import Yaml from 'js-yaml';

export const DefaultSidebars: SidebarsConfig = {
  defaultSidebar: [
    {
      type: 'autogenerated',
      dirName: '.',
    },
  ],
};

export const DisabledSidebars: SidebarsConfig = {};

// If a path is provided, make it absolute
// use this before loadSidebars()
export function resolveSidebarPathOption(
  siteDir: string,
  sidebarPathOption: PluginOptions['sidebarPath'],
): PluginOptions['sidebarPath'] {
  return sidebarPathOption
    ? path.resolve(siteDir, sidebarPathOption)
    : sidebarPathOption;
}

async function loadSidebarsFileUnsafe(
  sidebarFilePath: string | false | undefined,
): Promise<SidebarsConfig> {
  // false => no sidebars
  if (sidebarFilePath === false) {
    return DisabledSidebars;
  }

  // undefined => defaults to autogenerated sidebars
  if (typeof sidebarFilePath === 'undefined') {
    return DefaultSidebars;
  }

  // Non-existent sidebars file: no sidebars
  // Note: this edge case can happen on versioned docs, not current version
  // We avoid creating empty versioned sidebars file with the CLI
  if (!fs.existsSync(sidebarFilePath)) {
    return DisabledSidebars;
  }

  // We don't want sidebars to be cached because of hot reloading.
  return importFresh(sidebarFilePath);
}

export async function loadSidebarsFile(
  sidebarFilePath: string | false | undefined,
): Promise<SidebarsConfig> {
  const sidebarsConfig = await loadSidebarsFileUnsafe(sidebarFilePath);
  validateSidebars(sidebarsConfig);
  return sidebarsConfig;
}

export async function loadNormalizedSidebars(
  sidebarFilePath: string | false | undefined,
  params: NormalizeSidebarsParams,
): Promise<NormalizedSidebars> {
  return normalizeSidebars(await loadSidebarsFile(sidebarFilePath), params);
}

// Note: sidebarFilePath must be absolute, use resolveSidebarPathOption
export async function loadSidebars(
  sidebarFilePath: string | false | undefined,
  options: Omit<SidebarProcessorParams, 'categoriesMetadata'>,
): Promise<Sidebars> {
  const normalizeSidebarsParams: NormalizeSidebarsParams = {
    ...options.sidebarOptions,
    version: options.version,
    categoryLabelSlugger: createSlugger(),
  };
  const normalizedSidebars = await loadNormalizedSidebars(
    sidebarFilePath,
    normalizeSidebarsParams,
  );
  const categoriesMetadata = Object.fromEntries(
    await Promise.all(
      (
        await Globby('**/_category_.{json,yml,yaml}', {
          cwd: options.version.contentPath,
        })
      ).map(async (filePath) => {
        const content = await fs.readFile(
          path.join(options.version.contentPath, filePath),
          'utf-8',
        );
        try {
          return [
            path.dirname(filePath),
            validateCategoryMetadataFile(Yaml.load(content)),
          ] as [string, CategoryMetadataFile];
        } catch (e) {
          logger.error`The docs sidebar category metadata file path=${filePath} looks invalid!`;
          throw e;
        }
      }),
    ),
  );
  return processSidebars(normalizedSidebars, {...options, categoriesMetadata});
}
