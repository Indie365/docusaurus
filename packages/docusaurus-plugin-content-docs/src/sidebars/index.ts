/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import fs from 'fs-extra';
import importFresh from 'import-fresh';
import {
  Sidebars,
  SidebarItem,
  Sidebar,
  UnprocessedSidebarItem,
  UnprocessedSidebar,
  UnprocessedSidebars,
  DocMetadataBase,
  VersionMetadata,
  SidebarItemsGeneratorDoc,
  SidebarItemsGeneratorVersion,
  SidebarOptions,
  PluginOptions,
  SidebarItemsGeneratorOption,
  NumberPrefixParser,
} from '../types';
import {fixSidebarItemInconsistencies} from './utils';
import {validateSidebars} from './validation';
import {normalizeSidebars} from './normalization';
import {mapValues, pick, memoize} from 'lodash';
import combinePromises from 'combine-promises';
import {DefaultSidebarItemsGenerator} from './generator';
import path from 'path';

type ProcessorPropsBase = {
  sidebarItemsGenerator: SidebarItemsGeneratorOption;
  numberPrefixParser: NumberPrefixParser;
  docs: DocMetadataBase[];
  version: VersionMetadata;
  options: SidebarOptions;
};

type SidebarProcessorProps = ProcessorPropsBase & {
  unprocessedSidebar: UnprocessedSidebar;
};

type SidebarsProcessorProps = ProcessorPropsBase & {
  unprocessedSidebars: UnprocessedSidebars;
};

export const DefaultSidebars: UnprocessedSidebars = {
  defaultSidebar: [
    {
      type: 'autogenerated',
      dirName: '.',
    },
  ],
};

export const DisabledSidebars: UnprocessedSidebars = {};

// If a path is provided, make it absolute
// use this before loadSidebars()
export function resolveSidebarPathOption(
  siteDir: string,
  sidebarPathOption: PluginOptions['sidebarPath'],
): PluginOptions['sidebarPath'] {
  return sidebarPathOption
    ? path.resolve(siteDir, sidebarPathOption)
    : sidebarPathOption;
}

// TODO refactor: make async
// Note: sidebarFilePath must be absolute, use resolveSidebarPathOption
export function loadSidebars(
  sidebarFilePath: string | false | undefined,
  options: SidebarOptions,
): UnprocessedSidebars {
  // false => no sidebars
  if (sidebarFilePath === false) {
    return DisabledSidebars;
  }

  // undefined => defaults to autogenerated sidebars
  if (typeof sidebarFilePath === 'undefined') {
    return DefaultSidebars;
  }

  // unexisting sidebars file: no sidebars
  // Note: this edge case can happen on versioned docs, not current version
  // We avoid creating empty versioned sidebars file with the CLI
  if (!fs.existsSync(sidebarFilePath)) {
    return DisabledSidebars;
  }

  // We don't want sidebars to be cached because of hot reloading.
  const sidebarsConfig = importFresh(sidebarFilePath);
  validateSidebars(sidebarsConfig);

  return normalizeSidebars(sidebarsConfig, options);
}

export function toSidebarItemsGeneratorDoc(
  doc: DocMetadataBase,
): SidebarItemsGeneratorDoc {
  return pick(doc, [
    'id',
    'frontMatter',
    'source',
    'sourceDirName',
    'sidebarPosition',
  ]);
}

export function toSidebarItemsGeneratorVersion(
  version: VersionMetadata,
): SidebarItemsGeneratorVersion {
  return pick(version, ['versionName', 'contentPath']);
}

// Handle the generation of autogenerated sidebar items and other post-processing checks
export async function processSidebar({
  sidebarItemsGenerator,
  numberPrefixParser,
  unprocessedSidebar,
  docs,
  version,
  options,
}: SidebarProcessorProps): Promise<Sidebar> {
  // Just a minor lazy transformation optimization
  const getSidebarItemsGeneratorDocsAndVersion = memoize(() => ({
    docs: docs.map(toSidebarItemsGeneratorDoc),
    version: toSidebarItemsGeneratorVersion(version),
  }));

  async function handleAutoGeneratedItems(
    item: UnprocessedSidebarItem,
  ): Promise<SidebarItem[]> {
    if (item.type === 'category') {
      return [
        {
          ...item,
          items: (
            await Promise.all(item.items.map(handleAutoGeneratedItems))
          ).flat(),
        },
      ];
    }
    if (item.type === 'autogenerated') {
      return sidebarItemsGenerator({
        item,
        numberPrefixParser,
        defaultSidebarItemsGenerator: DefaultSidebarItemsGenerator,
        ...getSidebarItemsGeneratorDocsAndVersion(),
        options,
      });
    }
    return [item];
  }

  const processedSidebar = (
    await Promise.all(unprocessedSidebar.map(handleAutoGeneratedItems))
  ).flat();

  return processedSidebar.map(fixSidebarItemInconsistencies);
}

export async function processSidebars({
  sidebarItemsGenerator,
  numberPrefixParser,
  unprocessedSidebars,
  docs,
  version,
  options,
}: SidebarsProcessorProps): Promise<Sidebars> {
  return combinePromises(
    mapValues(unprocessedSidebars, (unprocessedSidebar) =>
      processSidebar({
        sidebarItemsGenerator,
        numberPrefixParser,
        unprocessedSidebar,
        docs,
        version,
        options,
      }),
    ),
  );
}
