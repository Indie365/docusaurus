/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {SidebarItemBase, SidebarItemLink, SidebarItemDoc} from '../types';
import {Joi} from '@docusaurus/utils-validation';

export type SidebarItemCategoryConfig = SidebarItemBase & {
  type: 'category';
  label: string;
  items: SidebarItemConfig[];
  collapsed?: boolean;
  collapsible?: boolean;
};

export type SidebarItemAutogeneratedConfig = SidebarItemBase & {
  type: 'autogenerated';
  dirName: string;
};

export type ValidSidebarItemConfig =
  | SidebarItemDoc
  | SidebarItemLink
  | SidebarItemAutogeneratedConfig
  | SidebarItemCategoryConfig;

export type SidebarItemConfig =
  | ValidSidebarItemConfig
  | string
  | SidebarCategoriesShorthand;

export type SidebarCategoriesShorthand = {
  [sidebarCategory: string]: SidebarItemConfig[];
};

export type SidebarConfig = SidebarCategoriesShorthand | SidebarItemConfig[];

// Sidebar given by user that is not normalized yet. e.g: sidebars.json
export type SidebarsConfig = {
  [sidebarId: string]: SidebarConfig;
};

export function isCategoriesShorthand(
  item: SidebarItemConfig,
): item is SidebarCategoriesShorthand {
  return typeof item !== 'string' && !item.type;
}

const sidebarItemBaseSchema = Joi.object<SidebarItemBase>({
  className: Joi.string(),
  customProps: Joi.object().unknown(),
});

const sidebarItemCategorySchema =
  sidebarItemBaseSchema.append<SidebarItemCategoryConfig>({
    type: 'category',
    label: Joi.string().required(),
    items: Joi.array().items(Joi.link('#sidebarItemSchema')).required(),
    collapsed: Joi.boolean(),
    collapsible: Joi.boolean(),
  });

const sidebarItemAutogeneratedSchema =
  sidebarItemBaseSchema.append<SidebarItemAutogeneratedConfig>({
    type: 'autogenerated',
    dirName: Joi.string()
      .required()
      .pattern(/^[^/](.*[^/])?$/)
      .message(
        '"dirName" must be a dir path relative to the docs folder root, and should not start or end with slash',
      ),
  });

const sidebarItemDocSchema = sidebarItemBaseSchema.append<SidebarItemDoc>({
  type: Joi.string().valid('doc', 'ref').required(),
  id: Joi.string().required(),
  label: Joi.string(),
});

const sidebarItemLinkSchema = sidebarItemBaseSchema.append<SidebarItemLink>({
  type: 'link',
  href: Joi.string().required(),
  label: Joi.string().required(),
});

const sidebarItemSchema = Joi.alternatives()
  .try(
    Joi.object().when('.type', {
      switch: [
        {is: 'link', then: sidebarItemLinkSchema},
        {
          is: Joi.string().valid('doc', 'ref').required(),
          then: sidebarItemDocSchema,
        },
        {is: 'autogenerated', then: sidebarItemAutogeneratedSchema},
        {is: 'category', then: sidebarItemCategorySchema},
        {
          is: 'subcategory',
          then: Joi.forbidden().messages({
            'any.unknown':
              'Docusaurus v2: "subcategory" has been renamed as "category".',
          }),
        },
      ],
      otherwise: Joi.forbidden().messages({
        'any.unknown': 'Unknown sidebar item type "{.type}".',
      }),
    }),
    Joi.object().pattern(
      Joi.string(),
      Joi.array().items(Joi.link('#sidebarItemSchema')),
    ),
    Joi.string(),
  )
  .id('sidebarItemSchema');

const sidebarSchema = Joi.alternatives().try(
  Joi.array().items(sidebarItemSchema),
  Joi.object().pattern(Joi.string(), sidebarItemSchema),
);

const sidebarsSchema = Joi.object().pattern(Joi.string(), sidebarSchema);

export function validateSidebarItem(
  item: Record<string, unknown>,
): asserts item is ValidSidebarItemConfig {
  Joi.assert(item, sidebarItemSchema);
}

export function validateSidebars(
  item: unknown,
): asserts item is SidebarsConfig {
  Joi.assert(item, sidebarsSchema);
}
