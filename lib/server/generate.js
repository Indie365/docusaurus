/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function execute() {
  const CWD = process.cwd();
  const fs = require('fs-extra');
  const readMetadata = require('./readMetadata.js');
  const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;
  const path = require('path');
  const color = require('color');
  const toSlug = require('../core/toSlug.js');
  const React = require('react');
  const mkdirp = require('mkdirp');
  const glob = require('glob');
  const chalk = require('chalk');
  const Site = require('../core/Site.js');
  const env = require('./env.js');
  const siteConfig = require(CWD + '/siteConfig.js');
  const translate = require('./translate.js');
  const getDoc = require('./getDoc.js');
  const getPage = require('./getPage.js');
  const feed = require('./feed.js');
  const sitemap = require('./sitemap.js');

  const join = path.join;

  const possibleLanguages = env.translation.enabledLanguageTags().push(undefined);

  // create the folder path for a file if it does not exist, then write the file
  function writeData(file, content) {
    console.log(`Creating: ${file}`);
    var parsed = path.parse(file)
    mkdirp.sync(parsed.dir);
    fs.writeFileSync(file, content);
  }

  // create the folder path for a file if it does not exist, then write the file
  function copyFile(source, target) {
    console.log(`Copying: ${source}`);
    var parsed = path.parse(source)
    mkdirp.sync(parsed.dir);
    fs.copyFile(source, target);
  }

  const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

  const getLanguageForPageFile = (filePath) => {
      // Calculate the language of the file from the path
      
      const pageLanguageRegex = /\/pages\/(.*)\//;
      const match = pageLanguageRegex.exec(sourceFile);
      const matches = match[1].split('/').filter(language => possibleLanguages.includes(language));
      const language = matches.length > 0 ? matches[0] : undefined;
  } 

  // takes the content of a doc article and returns the content with a table of
  // contents inserted
  const insertTableOfContents = rawContent => {
    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(rawContent))) {
      headers.push(match[1]);
    }

    const tableOfContents = headers
      .map(header => `  - [${header}](#${toSlug(header)})`)
      .join('\n');

    return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
  };

  // returns true if a file should be excluded from concatentation to
  // default Docusaurus styles
  function isSeparateCss(file) {
    if (!siteConfig.separateCss) {
      return false;
    }
    for (let i = 0; i < siteConfig.separateCss.length; i++) {
      if (file.includes(siteConfig.separateCss[i])) {
        return true;
      }
    }
    return false;
  }

  console.log('generate.js triggered...');

  readMetadata.generateMetadataDocs();
  const Metadata = require('../core/metadata.js');

  // TODO: what if the project is a github org page? We should not use
  // siteConfig.projectName in this case. Otherwise a GitHub org doc URL would
  // look weird: https://myorg.github.io/myorg/docs

  // TODO: siteConfig.projectName is a misnomer. The actual project name is
  // `title`. `projectName` is only used to generate a folder, which isn't
  // needed when the project's a GitHub org page

  const buildDir = join(CWD, 'build', siteConfig.projectName);

  fs.removeSync(join(CWD, 'build'));

  // DOCS: We already have all the correct languages in the metadata
  Object.keys(Metadata).forEach(id => {
    const metadata = Metadata[id];

    var reactApp = getDoc(metadata);

    const rawHtml = renderToStaticMarkup(reactApp);

    const targetFile = join(buildDir, metadata.permalink);
    writeData(targetFile, rawHtml);
  });

  // copy docs assets if they exist
  if (fs.existsSync(join(CWD, '..', readMetadata.getDocsPath(), 'assets'))) {
    fs.copySync(
      join(CWD, '..', readMetadata.getDocsPath(), 'assets'),
      join(buildDir, 'docs', 'assets')
    );
  }

  // create html files for all blog posts (each article)
  if (fs.existsSync(join(__dirname, '..', 'core', 'MetadataBlog.js'))) {
    fs.removeSync(join(__dirname, '..', 'core', 'MetadataBlog.js'));
  }
  readMetadata.generateMetadataBlog();
  const MetadataBlog = require('../core/MetadataBlog.js');
  const BlogPostLayout = require('../core/BlogPostLayout.js');

  let files = glob.sync(join(CWD, 'blog', '**', '*.*'));
  files
    .sort()
    .reverse()
    .forEach(file => {
      const extension = path.extname(file);
      if (extension !== '.md' && extension !== '.markdown') {
        return;
      }

      // convert filename to use slashes
      const filePath = path
        .basename(file)
        .replace('-', '/')
        .replace('-', '/')
        .replace('-', '/')
        .replace(/\.md$/, '.html');
      const result = readMetadata.extractMetadata(
        fs.readFileSync(file, {encoding: 'utf8'})
      );
      const rawContent = result.rawContent;
      const metadata = Object.assign(
        {path: filePath, content: rawContent},
        result.metadata
      );
      metadata.id = metadata.title;

      let language = 'en';
      const blogPostComp = (
        <BlogPostLayout
          metadata={metadata}
          language={language}
          config={siteConfig}>
          {rawContent}
        </BlogPostLayout>
      );
      const str = renderToStaticMarkup(blogPostComp);

      let targetFile = join(buildDir, 'blog', filePath);
      writeData(targetFile, str);
    });
  // create html files for all blog pages (collections of article previews)
  const BlogPageLayout = require('../core/BlogPageLayout.js');
  const perPage = 10;
  for (let page = 0; page < Math.ceil(MetadataBlog.length / perPage); page++) {
    let language = 'en';
    const metadata = {page: page, perPage: perPage};
    const blogPageComp = (
      <BlogPageLayout
        metadata={metadata}
        language={language}
        config={siteConfig}
      />
    );
    const str = renderToStaticMarkup(blogPageComp);

    let targetFile = join(
      buildDir,
      'blog',
      page > 0 ? 'page' + (page + 1) : '',
      'index.html'
    );
    writeData(targetFile, str);
  }
  // create rss files for all blog pages, if there are any blog files
  if (MetadataBlog.length > 0) {
    let targetFile = join(buildDir, 'blog', 'feed.xml');
    writeData(targetFile, feed());
    targetFile = join(buildDir, 'blog', 'atom.xml');
    writeData(targetFile, feed('atom'));
  }

  // create sitemap
  if (MetadataBlog.length > 0 && Object.keys(Metadata).length > 0) {
    let targetFile = join(buildDir, 'sitemap.xml');
    sitemap(xml => {
      writeData(targetFile, xml);
    });
  }

  // copy blog assets if they exist
  if (fs.existsSync(join(CWD, 'blog', 'assets'))) {
    fs.copySync(join(CWD, 'blog', 'assets'), join(buildDir, 'blog', 'assets'));
  }

  // copy all static files from docusaurus
  files = glob.sync(join(__dirname, '..', 'static', '**'));
  files.forEach(file => {
    var relativePath = path.relative(CWD, file)
    var isCss = file.match(/\.css$/);

    relativePath = join(CWD, relativePath);
    // parse css files to replace colors according to siteConfig
    if (isCss) {
      // Process the CSS.
      let rawCss = fs.readFileSync(file, 'utf8');

      if (
        !siteConfig.colors ||
        !siteConfig.colors.primaryColor ||
        !siteConfig.colors.secondaryColor
      ) {
        console.error(
          `${chalk.yellow(
            'Missing color configuration.'
          )} Make sure siteConfig.colors includes primaryColor and secondaryColor fields.`
        );
      }

      Object.keys(siteConfig.colors).forEach(key => {
        const color = siteConfig.colors[key];
        rawCss = rawCss.replace(new RegExp('\\$' + key, 'g'), color);
      });
      const codeColor = color(siteConfig.colors.primaryColor)
        .alpha(0.07)
        .string();
      rawCss = rawCss.replace(
        new RegExp('\\$codeColor', 'g'),
        codeColor
      );

      writeData(relativePath, rawCss);
    } else if (!fs.lstatSync(file).isDirectory()) {
      copyFile(file, relativePath);
    }
  });

  // STATIC
  files = glob.sync(join(CWD, 'static', '**'), {dot: true});
  files.forEach(file => {
    // parse css files to replace colors according to siteConfig
    if (file.match(/\.css$/) && !isSeparateCss(file)) {
      const mainCss = join(buildDir, 'css', 'main.css');
      let cssContent = fs.readFileSync(file, 'utf8');
      cssContent = fs.readFileSync(mainCss, 'utf8') + '\n' + cssContent;

      Object.keys(siteConfig.colors).forEach(key => {
        const color = siteConfig.colors[key];
        cssContent = cssContent.replace(new RegExp('\\$' + key, 'g'), color);
      });

      writeData(mainCss, cssContent);
    } else if (!fs.lstatSync(file).isDirectory()) {
      let parts = file.split('/static/');
      let targetFile = join(buildDir, parts[1]);
      writeData(file, targetFile);
    }
  });

  
  // We will create all the files we have, and fill in the blanks with the 'best' version.
  var fillTheGaps = [];
  
  // PAGES
  files = glob.sync(join(CWD, 'pages', '**'));
  // Foreach file
  files.forEach(sourceFile => {
    var isJs = sourceFile.match(/\.js$/);
    let isHtml = sourceFile.match(/\.html$/);
    
    const parts = sourceFile.split('pages');
    let targetFile = join(buildDir, parts[1]);
    
    const language = getLanguageForPageFile(filePath);
    var alternateLanguages = possibleLanguages.filter(alternative => alternative != language);
    const languagePart = language != undefined ? `${language}/` : '/' ;

    // HTML (copy paste)
    if (isHtml && siteConfig.wrapPagesHTML) {
      const rawHtml = getPage.getPageHtml(sourceFile, language);
      writeData(targetFile, rawHtml);

      // Add other languages to a list that we will execute at the end.
      fillTheGaps.concat(alternateLanguages.map(alternative => ({
          targetFile: targetFile.replace(languagePart, `${alternative}/`),
          rawHtml: getPage.getPageHtml(sourceFile, language)
      })));

      return; // Will not break the foreach
    }

    // JS (React)
    if (isJs) {
      targetFile = targetFile.replace(/\.js$/, '.html');

      const rawHtml = getPage.getPageJs(sourceFile, language)
      writeData(targetFile, rawHtml);

      // Add other languages to a list that we will execute at the end. (But not replace files)
      fillTheGaps.concat(alternateLanguages.map(alternative => ({
        targetFile: targetFile.replace(languagePart, `${alternative}/`),
        rawHtml: getPage.getPageHtml(sourceFile, language)
      })));

      return; // Will not break the foreach
    }

    // Static files (PNG, md, txt etc.) that happen to be in the pages folder
    if (!fs.lstatSync(sourceFile).isDirectory()) {
      mkdirp.sync(targetFile.replace(new RegExp('/[^/]*$'), ''));
      fs.copySync(sourceFile, targetFile);
      return;
    }

    fillTheGaps.forEach(info => {
      if (fs.existsSync(info.targetFile)) return; // Will not break the foreach
      writeData(info.targetFile, info.rawHtml);
    });

  });

  // Generate CNAME file if a custom domain is specified in siteConfig
  if (siteConfig.cname) {
    let targetFile = join(buildDir, 'CNAME');
    fs.writeFileSync(targetFile, siteConfig.cname);
  }
}

module.exports = execute;
