const fs = require('fs-extra');
const React = require('react');
const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;

const path = require('path');
const join = path.join;

const env = require('./env.js');
const readMetadata = require('./readMetadata.js');
const DocsLayout = require('../core/DocsLayout.js');
const MarkdownBlock = require('../core/MarkdownBlock.js');

const CWD = process.cwd();
const siteConfig = require(CWD + '/siteConfig.js');

class Markdown {
  // links to markdown files => links to their website htmls
  mdToHtml(Metadata) {
    const mdToHtml = {};
    Object.keys(Metadata).forEach(id => {
      const metadata = Metadata[id];
      if (metadata.language !== 'en' || metadata.original_id) {
        return;
      }
      let htmlLink =
        siteConfig.baseUrl + metadata.permalink.replace('/next/', '/');
      if (htmlLink.includes('/docs/en/')) {
        htmlLink = htmlLink.replace('/docs/en/', '/docs/en/VERSION/');
      } else {
        htmlLink = htmlLink.replace('/docs/', '/docs/VERSION/');
      }
      mdToHtml[metadata.source] = htmlLink;
    });
    return mdToHtml;
  }
}

class Docs {
  // determine what file to use according to its id
  metaToFile(metadata) {
    const language = metadata.language;
    if (metadata.original_id) {
      return env.translation.enabled && metadata.language !== 'en'
        ? join(CWD, 'translated_docs', metadata.language, metadata.source)
        : join(CWD, 'versioned_docs', metadata.source);
    } else {
      return env.translation.enabled && metadata.language !== 'en'
        ? join(CWD, 'translated_docs', metadata.language, metadata.source)
        : join(CWD, '..', readMetadata.getDocsPath(), metadata.source);
    }
  }

  tableOfContent(content) {
    const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(content))) {
      headers.push(match[1]);
    }

    return headers
      .map(header => `  - [${header}](#${toSlug(header)})`)
      .join('\n');
  }

  render(metadata, mdToHtml) {
    const file = this.metaToFile(metadata);
    if (!fs.existsSync(file)) {
      return;
    }

    let rawContent = readMetadata.extractMetadata(fs.readFileSync(file, 'utf8'))
      .rawContent;

    const latestVersion = env.versioning.latestVersion;
    const version = metadata.version;
    const layout = metadata.layout;
    const language = metadata.language;

    // table of content
    const toc = this.tableOfContent(rawContent);
    rawContent = rawContent.replace(toc);

    // markdown links
    Object.keys(mdToHtml).forEach(function(key, index) {
      const link = mdToHtml[key]
        .replace('/en/', '/' + language + '/')
        .replace(
          '/VERSION/',
          version && version !== latestVersion ? '/' + version + '/' : '/'
        );
      rawContent = rawContent.replace(
        new RegExp('\\]\\((\\./)?' + key, 'g'),
        '](' + link
      );
    });

    // asset links
    rawContent = rawContent.replace(
      /\]\(assets\//g,
      '](' + siteConfig.baseUrl + 'docs/assets/'
    );

    let Doc;
    if (layout && siteConfig.layouts && siteConfig.layouts[layout]) {
      Doc = siteConfig.layouts[layout]({
        React,
        MarkdownBlock: MarkdownBlock,
      });
    }

    const docComp = (
      <DocsLayout
        metadata={metadata}
        language={language}
        config={siteConfig}
        Doc={Doc}>
        {rawContent}
      </DocsLayout>
    );

    return renderToStaticMarkup(docComp);
  }
}

module.exports = {
  markdown: new Markdown(),
  docs: new Docs(),
};
