/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const fs = require('fs-extra');
const React = require('react');
const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;

const path = require('path');
const join = path.join;

const env = require('../env.js');
const readMetadata = require('../readMetadata.js');
const toSlug = require('../../core/toSlug.js');
const DocsLayout = require('../../core/DocsLayout.js');
const MarkdownBlock = require('../../core/MarkdownBlock.js');

const CWD = process.cwd();
const siteConfig = require(CWD + '/siteConfig.js');

const mdToHref = Metadata => {
  // links to links based on filename.md => links based on permalink.href
  const dictionary = {};
  Object.keys(Metadata).forEach(id => {
    const metadata = Metadata[id];
    dictionary[metadata.source] = metadata.permalink.substr(metadata.permalink.lastIndexOf('/') + 1)
  });

  return dictionary;
};  

// determine what file to use according to its id
const metaToFile = (metadata, language) => {
  let langPart = language != undefined ? language : '';

  if (metadata.original_id) {
    return metadata.language !== undefined
      ? join(CWD, 'translated_docs', langPart, metadata.source)
      : join(CWD, 'versioned_docs', langPart, metadata.source);
  } else {
    return join(CWD, '..', readMetadata.getDocsPath(), metadata.source);
  }
};

// Fills in the Table of Content Section
const tableOfContent = content => {
  const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

  const regexp = /\n###\s+(`.*`.*)\n/g;
  let match;
  const headers = [];
  while ((match = regexp.exec(content))) {
    headers.push(match[1]);
  }

  return headers
    .map(header => `  - [${header}](#${toSlug(header)})`)
    .join('\n');
};

// RENDER CALL
const renderDoc = (metadata, mdToHref) => {
  const file = metaToFile(metadata, metadata.language);
  const fallback = metaToFile(metadata, undefined);

  // We have to fallback at this point!
  // We can't just send a different metadata, as that will have a different language for dropdown etc.
  var checked = fs.existsSync(file)
    ? file
    : fs.existsSync(fallback) ? fallback : null;

  if (checked == null) return;

  let rawContent = readMetadata.extractMetadata(fs.readFileSync(file, 'utf8'))
    .rawContent;

  const latestVersion = env.versioning.latestVersion;
  const version = metadata.version;
  const layout = metadata.layout;
  const language = metadata.language;

  // table of content
  const toc = tableOfContent(rawContent);
  rawContent = rawContent.replace(toc);

  // Regular expression to match all markdown links
  // [site up and running locally](getting-started-site-creation.md#anchor) <--- Also supports anchors
  // Feel free to improve this regex, it's my first attempt.
  var regex = /\[.*?\]\( *(.*?\.md).*?\)/g;

  // Use the power of relative links to preserve versions and languages!
  // We also look up in a dictonary so it should be faster.
  rawContent = rawContent.replace(regex, function(match, link) {
    // return an appropriately-formatted link
    var replacement = mdToHref[link];

    // Invalid (or demo) markdown link, return original
    return replacement != undefined ? match.replace(link, replacement) : match;
  });

  // asset links
  rawContent = rawContent.replace(
    /\]\(assets\//g,
    '](' + siteConfig.baseUrl + 'docs/assets/'
  );

  let Doc;
  if (layout && siteConfig.layouts && siteConfig.layouts[layout]) {
    Doc = siteConfig.layouts[layout]({
      React,
      MarkdownBlock: MarkdownBlock,
    });
  }

  const docComp = (
    <DocsLayout metadata={metadata} config={siteConfig} Doc={Doc}>
      {rawContent}
    </DocsLayout>
  );

  return renderToStaticMarkup(docComp);
};

module.exports = {
  renderDoc,
  mdToHref,
};
