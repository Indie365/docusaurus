/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const fs = require('fs-extra');
const React = require('react');
const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;

const path = require('path');
const join = path.join;

const env = require('../env.js');
const readMetadata = require('../readMetadata.js');
const toSlug = require('../../core/toSlug.js');
const DocsLayout = require('../../core/DocsLayout.js');
const MarkdownBlock = require('../../core/MarkdownBlock.js');

const CWD = process.cwd();
const siteConfig = require(CWD + '/siteConfig.js');

const mdToHtml = (Metadata) => {
  // links to markdown files => links to their website htmls
  const mdToHtml = {};
  Object.keys(Metadata).forEach(id => {
    const metadata = Metadata[id];
    if (metadata.language !== 'en' || metadata.original_id) {
      return;
    }
    let htmlLink =
      siteConfig.baseUrl + metadata.permalink.replace('/next/', '/');
    if (htmlLink.includes('/docs/en/')) {
      htmlLink = htmlLink.replace('/docs/en/', '/docs/en/VERSION/');
    } else {
      htmlLink = htmlLink.replace('/docs/', '/docs/VERSION/');
    }
    mdToHtml[metadata.source] = htmlLink;
  });
  return mdToHtml;
}

// determine what file to use according to its id
const metaToFile = (metadata, language) => {
  let langPart = language != undefined ? language : '';

  if (metadata.original_id) {
    return metadata.language !== undefined
      ? join(CWD, 'translated_docs', langPart, metadata.source)
      : join(CWD, 'versioned_docs', langPart, metadata.source);
  } else {
    return join(CWD, '..', readMetadata.getDocsPath(), metadata.source);
  }
}

// Fills in the Table of Content Section
const tableOfContent = (content) => {
  const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

  const regexp = /\n###\s+(`.*`.*)\n/g;
  let match;
  const headers = [];
  while ((match = regexp.exec(content))) {
    headers.push(match[1]);
  }

  return headers
    .map(header => `  - [${header}](#${toSlug(header)})`)
    .join('\n');
}

// RENDER CALL
const renderDoc = (metadata, mdToHtml) => {
  const file = metaToFile(metadata, metadata.language);
  const fallback = metaToFile(metadata, undefined);
  
  // We have to fallback at this point!
  // We can't just send a different metadata, as that will have a different language for dropdown etc.
  var checked = 
    fs.existsSync(file) ? file 
    : fs.existsSync(fallback) ? fallback : null;

  if (checked == null) return;

  let rawContent = readMetadata.extractMetadata(fs.readFileSync(file, 'utf8'))
    .rawContent;

  const latestVersion = env.versioning.latestVersion;
  const version = metadata.version;
  const layout = metadata.layout;
  const language = metadata.language;

  // table of content
  const toc = tableOfContent(rawContent);
  rawContent = rawContent.replace(toc);

  // markdown links
  Object.keys(mdToHtml).forEach(function(key, index) {
    const link = mdToHtml[key]
      .replace('/en/', '/' + language + '/')
      .replace(
        '/VERSION/',
        version && version !== latestVersion ? '/' + version + '/' : '/'
      );
    rawContent = rawContent.replace(
      new RegExp('\\]\\((\\./)?' + key, 'g'),
      '](' + link
    );
  });

  // asset links
  rawContent = rawContent.replace(
    /\]\(assets\//g,
    '](' + siteConfig.baseUrl + 'docs/assets/'
  );

  let Doc;
  if (layout && siteConfig.layouts && siteConfig.layouts[layout]) {
    Doc = siteConfig.layouts[layout]({
      React,
      MarkdownBlock: MarkdownBlock,
    });
  }

  const docComp = (
    <DocsLayout
      metadata={metadata}
      config={siteConfig}
      Doc={Doc}>
      {rawContent}
    </DocsLayout>
  );

  return renderToStaticMarkup(docComp);
}

module.exports = {
  renderDoc,
  mdToHtml
};
