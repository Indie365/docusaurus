const filepath = require('filepath');
const fm = require('front-matter');
const fs = require('fs-extra');
const glob = require('glob-promise');
const rimraf = require('rimraf');
const shell = require('shelljs');
const path = require('path');
const join = path.join;

const CWD = process.cwd();

const siteConfig = require(CWD + '/website/siteConfig.js');
const buildDir = join(CWD, 'website', 'build');
const outputDir = join(buildDir, siteConfig.projectName);
const docsDir = join(CWD,'docs');
const staticCSSDir = join(CWD,'website','static','css');
const translationDirectory = join(CWD,'website','i18n');

let inputMarkdownFiles = [];
let inputAssetsFiles = [];
let outputHTMLFiles = [];
let outputAssetsFiles = [];

const buildFromCommandLine = () => {
  shell.cd('website');
  shell.exec('yarn write-translations');
  shell.exec('yarn build');
}

const clearFiles = () => {
  fs.removeSync(buildDir);
  fs.removeSync(translationDirectory);
}

beforeEach(() => {
  shell.cd(CWD);
});

beforeAll(() => {
  clearFiles();
  buildFromCommandLine();
  return Promise.all([
    glob(join(docsDir, '**', '*.md')),
    glob(join(outputDir, 'docs', '*.html')),
    glob(join(docsDir, 'assets', '*')),
    glob(join(outputDir, 'img', '*')),
  ]).then(function(results) {
    inputMarkdownFiles = results[0];
    outputHTMLFiles = results[1];
    inputAssetsFiles = results[2];
    outputAssetsFiles = results[3];
    return;
  });
});

afterAll(() => {
  clearFiles();
});

test('Build folder exists', function() {
  return fs.stat(buildDir).then(function(status) {
    expect(status.isDirectory()).toBeTruthy();
  });
});

test('Project folder exists', () => {
  return fs.stat(outputDir).then(function(status) {
    expect(status.isDirectory()).toBeTruthy();
  });
});

test('Generated HTML for each Markdown resource', function() {
  let metadata = [];
  outputHTMLFiles.forEach(function(file) {
    const path = filepath.create(file);
    metadata.push(path.basename());
  });
  inputMarkdownFiles.forEach(function(file) {
    const path = filepath.create(file);
    const data = fs.readFileSync(file, 'utf8');
    const frontmatter = fm(data);
    expect(metadata).toContain(frontmatter.attributes.id + '.html');
  });
});

// Is it okay to prefer the arrow function for these?
test('Index.html exists', () => {
  const indexFile = join(outputDir, 'index.html');
  const exists = fs.existsSync(indexFile);
  expect(exists).toBeTruthy();
});

test('Generated table of contents', function() {
  outputHTMLFiles.forEach(function(file) {
    const fileContents = fs.readFileSync(file, 'utf8');
    expect(fileContents).not.toContain('<AUTOGENERATED_TABLE_OF_CONTENTS>');
  });
});

test('Concatenated CSS files', function() {
  const mainCssFile = join(outputDir, 'css', 'main.css');

  return Promise.all([
    glob(staticCSSDir + '/*.css'),
    fs.readFile(mainCssFile, 'utf8'),
  ]).then(function(results) {
    const inputFiles = results[0];
    const outputFile = results[1];
    inputFiles.forEach(function(file) {
      const contents = fs.readFileSync(file, 'utf8');
      expect(outputFile).toContain(contents);
    });
  });
});

test('Copied assets from /docs/assets', function() {
  let metadata = [];
  outputAssetsFiles.forEach(function(file) {
    const path = filepath.create(file);
    metadata.push(path.basename());
  });
  inputAssetsFiles.forEach(function(file) {
    const path = filepath.create(file);
    expect(metadata).toContain(path.basename());
  });
});
